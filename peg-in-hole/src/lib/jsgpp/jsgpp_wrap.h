/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 3.0.8
 *
 * This file is not intended to be easily readable and contains a number of
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG
 * interface file instead.
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_jsgpp_WRAP_H_
#define SWIG_jsgpp_WRAP_H_

class SwigDirector_ConjugateGradients : public sgpp::solver::ConjugateGradients, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_ConjugateGradients(JNIEnv *jenv, size_t imax, double epsilon);
    virtual ~SwigDirector_ConjugateGradients();
    virtual void solve(sgpp::base::OperationMatrix &SystemMatrix, sgpp::base::DataVector &alpha, sgpp::base::DataVector &b, bool reuse = false, bool verbose = false, double max_threshold = -1.0);
    virtual void starting();
    virtual void calcStarting();
    virtual void iterationComplete();
    virtual void complete();
public:
    bool swig_overrides(int n) {
      return (n < 8 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<8> swig_override;
};

class SwigDirector_OptScalarFunction : public sgpp::optimization::ScalarFunction, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptScalarFunction(JNIEnv *jenv, size_t d);
    virtual ~SwigDirector_OptScalarFunction();
    virtual double eval(sgpp::base::DataVector const &x);
    virtual void clone(std::unique_ptr< sgpp::optimization::ScalarFunction > &clone) const;
public:
    bool swig_overrides(int n) {
      return (n < 2 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<2> swig_override;
};

class SwigDirector_OptScalarFunctionGradient : public sgpp::optimization::ScalarFunctionGradient, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptScalarFunctionGradient(JNIEnv *jenv, size_t d);
    virtual ~SwigDirector_OptScalarFunctionGradient();
    virtual double eval(sgpp::base::DataVector const &x, sgpp::base::DataVector &gradient);
    virtual void clone(std::unique_ptr< sgpp::optimization::ScalarFunctionGradient > &clone) const;
public:
    bool swig_overrides(int n) {
      return (n < 2 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<2> swig_override;
};

class SwigDirector_OptScalarFunctionHessian : public sgpp::optimization::ScalarFunctionHessian, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptScalarFunctionHessian(JNIEnv *jenv, size_t d);
    virtual ~SwigDirector_OptScalarFunctionHessian();
    virtual double eval(sgpp::base::DataVector const &x, sgpp::base::DataVector &gradient, sgpp::base::DataMatrix &hessian);
    virtual void clone(std::unique_ptr< sgpp::optimization::ScalarFunctionHessian > &clone) const;
public:
    bool swig_overrides(int n) {
      return (n < 2 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<2> swig_override;
};

class SwigDirector_OptVectorFunction : public sgpp::optimization::VectorFunction, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptVectorFunction(JNIEnv *jenv, size_t d, size_t m);
    virtual ~SwigDirector_OptVectorFunction();
    virtual void eval(sgpp::base::DataVector const &x, sgpp::base::DataVector &value);
    virtual void clone(std::unique_ptr< sgpp::optimization::VectorFunction > &clone) const;
public:
    bool swig_overrides(int n) {
      return (n < 2 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<2> swig_override;
};

class SwigDirector_OptVectorFunctionGradient : public sgpp::optimization::VectorFunctionGradient, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptVectorFunctionGradient(JNIEnv *jenv, size_t d, size_t m);
    virtual ~SwigDirector_OptVectorFunctionGradient();
    virtual void eval(sgpp::base::DataVector const &x, sgpp::base::DataVector &value, sgpp::base::DataMatrix &gradient);
    virtual void clone(std::unique_ptr< sgpp::optimization::VectorFunctionGradient > &clone) const;
public:
    bool swig_overrides(int n) {
      return (n < 2 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<2> swig_override;
};

class SwigDirector_OptVectorFunctionHessian : public sgpp::optimization::VectorFunctionHessian, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptVectorFunctionHessian(JNIEnv *jenv, size_t d, size_t m);
    virtual ~SwigDirector_OptVectorFunctionHessian();
    virtual void eval(sgpp::base::DataVector const &x, sgpp::base::DataVector &value, sgpp::base::DataMatrix &gradient, std::vector< sgpp::base::DataMatrix > &hessian);
    virtual void clone(std::unique_ptr< sgpp::optimization::VectorFunctionHessian > &clone) const;
public:
    bool swig_overrides(int n) {
      return (n < 2 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<2> swig_override;
};

class SwigDirector_OptIterativeGridGenerator : public sgpp::optimization::IterativeGridGenerator, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptIterativeGridGenerator(JNIEnv *jenv, sgpp::optimization::ScalarFunction &f, sgpp::base::Grid &grid, size_t N);
    virtual ~SwigDirector_OptIterativeGridGenerator();
    virtual bool generate();
public:
    bool swig_overrides(int n) {
      return (n < 1 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<1> swig_override;
};

class SwigDirector_OptSLE : public sgpp::optimization::SLE, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptSLE(JNIEnv *jenv);
    virtual ~SwigDirector_OptSLE();
    virtual bool isMatrixEntryNonZero(size_t i, size_t j);
    virtual double getMatrixEntry(size_t i, size_t j);
    virtual void matrixVectorMultiplication(sgpp::base::DataVector const &x, sgpp::base::DataVector &y);
    virtual size_t countNNZ();
    virtual size_t getDimension() const;
    virtual bool isCloneable() const;
public:
    bool swig_overrides(int n) {
      return (n < 6 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<6> swig_override;
};

class SwigDirector_OptSLESolver : public sgpp::optimization::sle_solver::SLESolver, public Swig::Director {

public:
    void swig_connect_director(JNIEnv *jenv, jobject jself, jclass jcls, bool swig_mem_own, bool weak_global);
    SwigDirector_OptSLESolver(JNIEnv *jenv);
    virtual ~SwigDirector_OptSLESolver();
    virtual bool solve(sgpp::optimization::SLE &system, sgpp::base::DataVector &b, sgpp::base::DataVector &x) const;
    virtual bool solve(sgpp::optimization::SLE &system, sgpp::base::DataMatrix &B, sgpp::base::DataMatrix &X) const;
public:
    bool swig_overrides(int n) {
      return (n < 2 ? swig_override[n] : false);
    }
protected:
    Swig::BoolArray<2> swig_override;
};


#endif
